{
  
    
        "post0": {
            "title": "Lazy Evaluation & Late Binding: Unexpected Behavior of Iterables in Python",
            "content": "Glossary . iterable in Python: . An object capable of returning its members one at a time. . Anything that can be used in a for loop, such as list, tuple, str, dict, set and iterators. We can convert an iterable to an iterator, which is actually what for statement does, by passing it to the built-in function iter(). . iterator in Python: . An object representing a stream of data. . It must have the __next__() method (or can be passed to the built-in function next()), such as generators, map objects. . The Problem . Recently, I’ve been practicing on Leetcode. In problem 373. Find K Pairs with Smallest Sums, I implemented a solution inspired by discussions in the community using heapq.merge in Python as follows: . def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]: import heapq # we have m*n pairs, imagine a m*n matrix rows = (([u, v] for v in nums2) for u in nums1) # since both nums1 and nums2 are ascending # each row is already sorted based on the sum of u and v # regular slicing cannot be applied to generator since &#39;generator&#39; object does not have __getitem__ # we should use itertools.islice return list(itertools.islice(heapq.merge(*rows, key=sum), k)) print(kSmallestPairs(nums1=[1, 7, 11], nums2=[2, 4, 6], k=9)) . The main idea of heapq.merge is like a multi-way merge sort on many already-sorted iterables. The difference is that heapq.merge uses a heap for ordering. Heap is just a binary tree in Python, and it is implemented with an array. heapq.merge initially collects the first element of each input iterable to form a list, then it heapify the list, transforming it to a heap. The first element of heap—h[0], is always the smallest in the heap (supposing it is a min-heap). heap.merge just pop h[0] and puts it into the result iterator, and then push the following element of h[0] from the same input iterable into the heap (more details at source code). We can also use heap as a priority queue. . Back to the previous code, rows is a generator of generators. We expect k pairs of smallest sums as the output, which should be: . [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [7, 6], [11, 2], [11, 4], [11, 6]] . However, the output actually is: . [[11, 2], [11, 2], [11, 2], [11, 4], [11, 4], [11, 4], [11, 6], [11, 6], [11, 6]] . Is something wrong with the generator? Try following code: . nums1=[1, 7, 11] nums2=[2, 4, 6] rows = (([u, v] for v in nums2) for u in nums1) for row in rows: for element in row: print(element, end=&#39; &#39;) . Surprisingly, the output is what we expect: . [1, 2] [1, 4] [1, 6] [7, 2] [7, 4] [7, 6] [11, 2] [11, 4] [11, 6] . Lazy Evaluation . We know that generators in Python are lazy evaluation. An element in a generator is only evaluated when we iterate to it. Most other objects in Python are eager evaluation. . j = 1 L = [j for _ in range(4)] # list G = (j for _ in range(4)) # generator j = 2 print(L) # [1, 1, 1, 1] print(list(G)) # [2, 2, 2, 2] . In above snippet, list L is evaluated when j=1, while generator G is not evaluated until we call list(G), at that time j=2. . Back to the generator rows, if we make it a list of generators instead of a generator of generators: . rows = [([u, v] for v in nums2) for u in nums1] for row in rows: for element in row: print(element, end=&#39; &#39;) . We have output: . [11, 2] [11, 4] [11, 6] [11, 2] [11, 4] [11, 6] [11, 2] [11, 4] [11, 6] . The output is different from when rows is a generator, but it is similar to the output of heapq.merge. The only difference is we did not sort the list as in heapq.merge. . If we think about the evaluation mechanism, when we create rows as a list, since list is eager evaluation, u should be 11 after that line is executed. That is why when we iterate those three generators later, the first elements of all pairs are 11. When rows is a generator, since generators are lazy evaluation, the value of u only changes after we finish iterating each row. . Back to heapq.merge, which is actually heapq.merge(*iterables, key=None, reverse=False). The first parameter iterables becomes a tuple after it receives input iterables. We can easily check this by following snippet: . rows = (([u, v] for v in nums2) for u in nums1) def func(*iterables): print(type(iterables)) # &lt;class &#39;tuple&#39;&gt; for it in iterables: for pair in it: print(pair, end=&#39; &#39;) func(*rows) # [11, 2] [11, 4] [11, 6] [11, 2] [11, 4] [11, 6] [11, 2] [11, 4] [11, 6] . The output is the same as when rows is a list even if we pass rows as a generator. Because it is converted to a tuple in the function, and tuple is also eager evaluation just like list. . However, even if heapq.merge does not convert rows to a tuple, we still cannot expect correct output. We mentioned before that heapq.merge initially collects the first element of each input iterable, considering following code: . rows = (([u, v] for v in nums2) for u in nums1) it1 = next(rows) print(next(it1)) # [1, 2] it2 = next(rows) print(next(it1)) # [7, 4], we expect [1, 4] print(next(it2)) # [7, 2] it3 = next(rows) print(next(it1)) # [11, 6], we expect [1, 6] print(next(it2)) # [11, 4], we expect [7, 4] print(next(it3)) # [11, 2] . We find that every time we call next(rows), the value of u changes. Thus, even if heapq.merge dose not convert rows to a tuple, we can only guarantee correct pairs for the first element in each generator. After that, the first value of all subsequent pairs will be the same. . Solution . The correct way to solve the above problem is to make rows a map object: . rows = map(lambda u: ([u, v] for v in nums2), nums1) print(list(heapq.merge(*rows, key=sum))) # [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [7, 6], [11, 2], [11, 4], [11, 6]] . This map object is also converted to a tuple when passing to heapq.merge, however, it gives us correct result. map objects are iterators, using lazy evaluation just like generators. The difference here is that this uses a function to create three generators. That u here is a parameter of the lambda function, not a single variable that holds the value of an element in nums1, and this function will be called three times with different values passed in. Therefore, this actually has nothing to do with map. It really depends on what u is. If we define rows as follows, we can also get the correct output: . rows = ((lambda u: ([u, v] for v in nums2))(k) for k in nums1) print(list(heapq.merge(*rows, key=sum))) # [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [7, 6], [11, 2], [11, 4], [11, 6]] rows = [(lambda u: ([u, v] for v in nums2))(k) for k in nums1] print(list(heapq.merge(*rows, key=sum))) # [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [7, 6], [11, 2], [11, 4], [11, 6]] . We replaced u with k, which holds the value of the element currently being iterated in nums1, to make the structure more clear. However, this is not necessary since even if we use u to iterate nums1, in the lambda function, u will be overwritten by the parameter u of the function. . To better understand how this u affects the output, we can also use lambda expressions to write the equivalents of previous definitions of rows that give us incorrect results: . rows = (([u, v] for v in nums2) for u in nums1) # is equivalent to rows = ((lambda: ([u, v] for v in nums2))() for u in nums1) rows = [([u, v] for v in nums2) for u in nums1] # is equivalent to rows = [(lambda: ([u, v] for v in nums2))() for u in nums1] . Late Binding . I also want to mention late binding here because it usually leads to unexpected behavior in Python, though not specifically limited to iterables. According to Wikipedia: . Late binding, dynamic binding, or dynamic linkage is a computer programming mechanism in which the method being called upon an object or the function being called with arguments is looked up by name at runtime. . There is a good article talking about late binding in Python. We will use some snippets to figure out how late binding works. . funcs = [lambda: u for u in range(5)] for func in funcs: print(func(), end=&#39; &#39;) # 4 4 4 4 4 . The output again is a repeat of the last element of range(5). We defined funcs, which is a list of 5 functions. Each function does not accept any parameters and returns u, which holds the value of the element being iterated in range(5). These functions are not called until we enter the following for loop and use func(). . Late binding means that values of variables used in a function are looked up at the time the function is called. When we call those five functions in funcs, they will all look up the value of u, which becomes 4 after we define funcs, because funcs, which is a list, use eager evaluation. However, if we define funcs as generators, the output becomes what we expect: . funcs = (lambda: u for u in range(5)) for func in funcs: print(func(), end=&#39; &#39;) # 0 1 2 3 4 . This is obvious since generators use lazy evaluation. The value of u changes along the for loop. . Another example of late binding without iterables: . i = 1 def func(): return i i = 2 print(func()) # 2 .",
            "url": "https://graysonliu.github.io/blog/coding/python/iterator/lazy-evaluation/late-binding/leetcode/heap/2020/09/22/lazy-evaluation-late-binding-unexpected-behavior-of-iterables-in-python.html",
            "relUrl": "/coding/python/iterator/lazy-evaluation/late-binding/leetcode/heap/2020/09/22/lazy-evaluation-late-binding-unexpected-behavior-of-iterables-in-python.html",
            "date": " • Sep 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Using a Forked Jekyll Theme for Github Pages",
            "content": "Switch to Jekyll . I have abandoned blogging for a very long time. I used to build my blog on Hexo and hosted it on Github Pages. A major drawback of this solution is that we have to first generate all static files locally, and then push all those files to the remote repository. As for Jekyll, since it is officially supported by Github Pages, we only need to push sources to the remote repository. Github Pages will generate the static site automatically, and those static files are not a part of our repository, making our repo much tidier. . There is a great guide on blogging with Github Pages and Jekyll, but this solution also has a pain point. Although Jekyll has plenty of plugins developed by the community, Github Pages only supports some specific ones, let alone most supported plugins are of an older version without newest features. If we want to beautify or add features to the blog, we have to modify corresponding templates by ourselves. Of course, we can add those modified templates to our Github Pages repo directly, but what if we want to use them as a separate theme like a Ruby gem. If this new theme is a fork of an existing theme, we might also want to update it from the upstream. Although Github Pages only supports specific Jekyll plugins, it could utilize any Jekyll theme that is hosted on Github. Therefore, we need to create our own Jekyll theme and host it on Github, then specify it as the the theme that should be used by Github Pages. . Configuration . I forked the minima theme and plan to develop my own theme based on it. Give the forked repo a new name, better to be the name you want for this new theme, e.g. minima-graysonliu. Then, in *.gemspec, simply change the value of spec.name to minima-graysonliu. We now have a Github-hosted Jekyll theme called minima-graysonliu. To use this theme, navigate to our Github Pages repo, in _config.yml, delete the following line: . theme: ... . and add a new line: . remote_theme: graysonliu/minima-graysonliu . The value of the remote_theme is just the name of your new theme repo hosted on Github, and we are done. . Other changes are needed if we want to modify and test our new theme locally. We first clone both the blog (Github Pages) repo and the theme repo to our local disk. In Gemfile of the blog repo, change . # This is the default theme for new Jekyll sites. You may change this to anything you like. gem &quot;minima&quot; . to . # This is the default theme for new Jekyll sites. You may change this to anything you like. gem &quot;minima-graysonliu&quot;, :path =&gt; &quot;/LOCAL_PATH_TO_THEME_REPO/minima-graysonliu&quot; . Update with: . bundle update . Even if _config.yml in the blog repo does not have the key theme (because we replaced it with remote_theme), since we specify minima-graysonliu as the default theme, Jekyll will use it when we run the server locally. . If we need to keep our forked new theme updated with the original theme, just set the original repo as its upstream and sync the fork regularly. .",
            "url": "https://graysonliu.github.io/blog/jekyll/blog/git/github-pages/2020/09/21/using-a-forked-jekyll-theme-for-github-pages.html",
            "relUrl": "/jekyll/blog/git/github-pages/2020/09/21/using-a-forked-jekyll-theme-for-github-pages.html",
            "date": " • Sep 21, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://graysonliu.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://graysonliu.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://graysonliu.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://graysonliu.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}